generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  walletAddress    String   @id @db.VarChar(44)
  tier            String   @default("standard") // "premium" or "standard"
  walletSource    String   @default("app")      // "seeker" or "app"
  genesisVerified Boolean  @default(false)
  allyBalance     Decimal  @default(0) @db.Decimal(18, 6)
  totalInteractionScore Int @default(0)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  // Relations
  posts           Post[]
  replies         Reply[]
  interactions    Interaction[]
  gamesAsPlayer1  Game[]   @relation("Player1Games")
  gamesAsPlayer2  Game[]   @relation("Player2Games")
  gamesWon        Game[]   @relation("WonGames")
  reports         Report[]
  
  @@map("users")
}

model Post {
  id              String   @id @default(cuid())
  authorWallet    String   @db.VarChar(44)
  content         String   @db.Text
  topic           String   @db.VarChar(50)
  subtopic        String   @db.VarChar(100)
  
  // Interaction counts (for quick display)
  likeCount       Int      @default(0)
  replyCount      Int      @default(0)
  tipCount        Int      @default(0)
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  // Relations
  author          User     @relation(fields: [authorWallet], references: [walletAddress])
  replies         Reply[]
  game            Game?
  
  @@map("posts")
}

model Reply {
  id              String   @id @default(cuid())
  postId          String
  authorWallet    String   @db.VarChar(44)
  content         String   @db.Text
  parentReplyId   String?  // For nested replies
  
  likeCount       Int      @default(0)
  tipCount        Int      @default(0)
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  // Relations
  post            Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  author          User     @relation(fields: [authorWallet], references: [walletAddress])
  parentReply     Reply?   @relation("ReplyToReply", fields: [parentReplyId], references: [id])
  childReplies    Reply[]  @relation("ReplyToReply")
  
  @@map("replies")
}

model Interaction {
  id              String   @id @default(cuid())
  userWallet      String   @db.VarChar(44)
  targetType      String   @db.VarChar(10) // "post" or "reply"
  targetId        String   // ID of post or reply
  interactionType String   @db.VarChar(10) // "like", "tip"
  amount          Decimal? @db.Decimal(18, 6) // For tips
  
  createdAt       DateTime @default(now())
  
  // Relations
  user            User     @relation(fields: [userWallet], references: [walletAddress])
  
  // Prevent duplicate interactions
  @@unique([userWallet, targetId, interactionType])
  @@map("interactions")
}

model Game {
  id              String   @id @default(cuid())
  postId          String   @unique
  gameType        String   @db.VarChar(20) // "tictactoe", "rps", "coinflip", "connectfour"
  player1         String   @db.VarChar(44)
  player2         String?  @db.VarChar(44)
  currentTurn     String?  @db.VarChar(44)
  gameState       Json     // Board state, moves, etc.
  wager           Decimal  @db.Decimal(18, 6)
  winner          String?  @db.VarChar(44)
  status          String   @db.VarChar(20) // "waiting", "active", "completed", "cancelled"
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  // Relations
  post            Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  player1User     User     @relation("Player1Games", fields: [player1], references: [walletAddress])
  player2User     User?    @relation("Player2Games", fields: [player2], references: [walletAddress])
  winnerUser      User?    @relation("WonGames", fields: [winner], references: [walletAddress])
  
  @@map("games")
}

model Report {
  id              String   @id @default(cuid())
  reporterWallet  String   @db.VarChar(44)
  targetType      String   @db.VarChar(10) // "post" or "reply"
  targetId        String   // ID of post or reply
  reason          String   @db.VarChar(50) // "spam", "harassment", "inappropriate", "misinformation", "other"
  description     String?  @db.Text // Optional detailed description
  status          String   @default("pending") @db.VarChar(20) // "pending", "reviewed", "resolved", "dismissed"
  moderatorNotes  String?  @db.Text // Notes from moderator
  resolvedAt      DateTime?
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  // Relations
  reporter        User     @relation(fields: [reporterWallet], references: [walletAddress])
  
  // Prevent duplicate reports from same user for same content
  @@unique([reporterWallet, targetId])
  @@map("reports")
}